<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>EAN-13 Generator (Single + Bulk)</title>
    <script src="https://unpkg.com/jsbarcode@latest/dist/JsBarcode.all.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <!-- Font to outlines helper -->
    <script src="https://cdn.jsdelivr.net/npm/opentype.js@1.3.4/dist/opentype.min.js"></script>

    <style>
      * {
        box-sizing: border-box;
      }

      body {
        font-family: "PPNeueMontreal-Medium";
        padding: 24px;
        max-width: 900px;
        margin: 0 auto;
        min-height: 100dvh;
        box-sizing: border-box;
      }

      .controls {
        display: flex;
        gap: 8px;
        align-items: center;
        margin-bottom: 16px;
        flex-wrap: wrap;
      }

      input[type="text"],
      textarea {
        padding: 6px 10px;
        font-size: 14px;
        font-family: inherit;
      }

      input[type="text"] {
        width: 180px;
      }

      textarea {
        width: 100%;
        box-sizing: border-box;
        resize: none;
        height: 200px;
      }

      button {
        padding: 6px 12px;
        font-size: 14px;
        cursor: pointer;
        border: solid 2px black;
        background-color: black;
        color: white;
        border-radius: 3px;
        transition: all 0.7s ease;
      }

      button:hover {
        background-color: #d593f6;
        border-color: #d593f6;
        transition: all 0.1s ease;
      }

      #error,
      #bulkError {
        color: #c00;
        font-size: 12px;
        margin-top: 4px;
        white-space: pre-line;
      }

      h2 {
        margin-top: 32px;
        margin-bottom: 8px;
        font-size: 48px;
        font-weight: 500;
      }

      .label-controls {
        flex-direction: column;
        align-items: flex-start;
      }

      .label-row {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        width: 100%;
      }

      .label-row input {
        flex: 1;
      }

      .label {
        width: 570px;
        height: 730px;
        background-color: white;
        filter: drop-shadow(5px 5px 100px #00000014);
        margin-bottom: 120px;
        transform-origin: top left;
        scale: 0.75;
      }

      p {
        text-transform: uppercase;
        text-align: center;
        margin: 0;
        font-family: "PPNeueMontreal-Medium";
      }

      .label {
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        padding: 10px;
        outline: #d593f6;
      }
      .typography {
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        gap: 32px;
        height: inherit;
      }

      .coffee-class {
        font-size: 32px;
        padding: 12px 18px;
        border: 3px solid black;
        border-radius: 48px;
        display: inline-flex;
        width: fit-content;
      }

      p.coffee-region {
        font-family: "GaramondNarrowLightITC";
        font-size: 107px;
        line-height: 90%;
        letter-spacing: -0.03em;
      }

      .coffee-descriptors {
        font-size: 32px;
        line-height: 108%;
      }
      .coffee-method {
        font-size: 22px;
        line-height: 108%;
        max-width: 30%;
      }
    </style>
  </head>

  <body>
    <!-- Single code section -->
    <h2>Штрих-код EAN-13</h2>
    <div class="controls">
      <label>
        <input
          id="codeInput"
          type="text"
          value="4816196900019"
          maxlength="13"
        />
      </label>
      <button id="generateBtn">Сгенерироватть</button>
      <button id="downloadBtn">Скачать</button>
    </div>
    <div id="error"></div>
    <svg id="barcodePreview"></svg>

    <h2>Текст для этикетки</h2>
    <div class="controls label-controls">
      <div class="label-row">
        <input
          id="labelClassInput"
          type="text"
          value="Эспрессо"
          placeholder="Класс кофе"
        />
        <input
          id="labelRegionInput"
          type="text"
          value="Эфиопия сидамо"
          placeholder="Регион"
        />
      </div>
      <div class="label-row">
        <input
          id="labelDescriptorsInput"
          type="text"
          value="Абрикос, бергамот, цитрусовый микс"
          placeholder="Дескрипторы"
        />
        <input
          id="labelMethodInput"
          type="text"
          value="мытая обработка"
          placeholder="Метод обработки"
        />
      </div>
      <button id="downloadLabelBtn">Скачать этикетку (SVG)</button>
    </div>

    <div class="label" id="coffeeLabel">
      <div class="typography">
        <p class="coffee-class" id="labelCoffeeClass">Эспрессо</p>
        <p class="coffee-region" id="labelCoffeeRegion">Эфиопия сидамо</p>
        <p class="coffee-descriptors" id="labelCoffeeDescriptors">
          Абрикос, бергамот, цитрусовый микс
        </p>
        <p class="coffee-method" id="labelCoffeeMethod">мытая обработка</p>
      </div>
      <div class="barcode">
        <svg id="labelBarcode"></svg>
      </div>
    </div>

    <h2>Несколько EAN-13 (один на строчку)</h2>
    <textarea
      id="bulkInput"
      placeholder="481619690001
590123412345 
400638133393"
    ></textarea>
    <div class="controls">
      <button id="bulkDownloadBtn">Сгенерировать и скачать архив</button>
    </div>
    <div id="bulkError"></div>

    <script>
      // ------------ TEXT → OUTLINES HELPERS (no style changes) ------------

      const DEFAULT_FONT = "PPNeueMontreal-Medium";
      const FONT_URLS = {
        "PPNeueMontreal-Medium": "./PPNeueMontreal-Medium.ttf",
        "GaramondNarrowLightITC": "./GaramondNarrowLightITC.otf",
      };
      const fontPromises = {};
      const SVG_NS = "http://www.w3.org/2000/svg";
      const LABEL_TEXT_IDS = [
        "labelCoffeeClass",
        "labelCoffeeRegion",
        "labelCoffeeDescriptors",
        "labelCoffeeMethod",
      ];

      function normalizeFontFamily(family) {
        if (!family) return DEFAULT_FONT;
        return family.split(",")[0].trim().replace(/^["']|["']$/g, "") || DEFAULT_FONT;
      }

      function resolveFontName(family) {
        const normalized = normalizeFontFamily(family);
        return FONT_URLS[normalized] ? normalized : DEFAULT_FONT;
      }

      function loadFontByFamily(family) {
        const fontName = resolveFontName(family);
        if (!fontPromises[fontName]) {
          const url = FONT_URLS[fontName];
          fontPromises[fontName] = new Promise((resolve, reject) => {
            if (!window.opentype) {
              reject(new Error("opentype.js not loaded"));
              return;
            }
            opentype.load(url, function (err, font) {
              if (err) {
                console.error(`Error loading font "${fontName}" for outlining:`, err);
                fontPromises[fontName] = null;
                reject(err);
              } else {
                resolve(font);
              }
            });
          });
        }
        return fontPromises[fontName];
      }

      function getFontSizeFromText(textEl) {
        const direct = textEl.getAttribute("font-size");
        if (direct) return parseFloat(direct);

        const style = textEl.getAttribute("style") || "";
        const match = style.match(/font-size:\s*([\d.]+)px/);
        if (match) return parseFloat(match[1]);

        return 16; // fallback, but JsBarcode sets it explicitly anyway
      }

      function getFillFromText(textEl) {
        const direct = textEl.getAttribute("fill");
        if (direct && direct !== "none") return direct;

        const style = textEl.getAttribute("style") || "";
        const match = style.match(/fill:\s*([^;]+)/);
        if (match) return match[1].trim();

        return "#000000"; // default barcode text color
      }

      function getFontFamilyFromText(textEl) {
        const direct = textEl.getAttribute("font-family");
        if (direct) return direct;

        const style = textEl.getAttribute("style") || "";
        const match = style.match(/font-family:\s*([^;]+)/i);
        if (match) return match[1];

        return DEFAULT_FONT;
      }

      function isTransparentColor(color) {
        if (!color) return true;
        const normalized = color.trim().toLowerCase();
        return (
          normalized === "transparent" ||
          normalized.endsWith(",0)") ||
          normalized.endsWith(", 0)") ||
          normalized === "rgba(0, 0, 0, 0)"
        );
      }

      function lengthToPx(value, relativeTo = 1) {
        if (!value || value === "normal") return 0;
        if (value.endsWith("px")) return parseFloat(value);
        if (value.endsWith("em")) return parseFloat(value) * relativeTo;
        if (value.endsWith("rem")) {
          const rootSize =
            parseFloat(window.getComputedStyle(document.documentElement).fontSize) || 16;
          return parseFloat(value) * rootSize;
        }
        if (value.endsWith("%")) return (parseFloat(value) / 100) * relativeTo;
        const num = parseFloat(value);
        return Number.isFinite(num) ? num : 0;
      }

      function getLineHeightPx(value, fontSize) {
        if (!value || value === "normal" || value === "initial" || value === "inherit") {
          return fontSize * 1.2;
        }
        if (value.endsWith("px")) return parseFloat(value);
        if (value.endsWith("%")) return (parseFloat(value) / 100) * fontSize;
        if (value.endsWith("em")) return parseFloat(value) * fontSize;
        const unitlessMatch = value.match(/^([\d.]+)$/);
        if (unitlessMatch) return fontSize * parseFloat(unitlessMatch[1]);
        const num = parseFloat(value);
        return Number.isFinite(num) ? num : fontSize * 1.2;
      }

      function applyTextTransformValue(text, transform) {
        if (!text) return "";
        if (transform === "uppercase") return text.toUpperCase();
        if (transform === "lowercase") return text.toLowerCase();
        if (transform === "capitalize") {
          return text.replace(/\b\p{L}/gu, (char) => char.toUpperCase());
        }
        return text;
      }

      function getRelativeRect(element, rootRect) {
        const rect = element.getBoundingClientRect();
        return {
          x: rect.left - rootRect.left,
          y: rect.top - rootRect.top,
          width: rect.width,
          height: rect.height,
        };
      }

      function getTextWidth(font, text, fontSize, letterSpacing) {
        if (!text) return 0;
        let width = font.getAdvanceWidth(text, fontSize);
        if (letterSpacing) {
          width += letterSpacing * Math.max(text.length - 1, 0);
        }
        return width;
      }

      function buildPathForText(font, text, x, y, fontSize, letterSpacing) {
        if (!letterSpacing) {
          return font.getPath(text, x, y, fontSize);
        }

        const glyphs = font.stringToGlyphs(text);
        let currentX = x;
        const mergedPath = new opentype.Path();
        const scale = fontSize / font.unitsPerEm;

        glyphs.forEach((glyph) => {
          const glyphPath = glyph.getPath(currentX, y, fontSize);
          mergedPath.extend(glyphPath);
          const advance =
            glyph.advanceWidth && glyph.advanceWidth !== 0
              ? glyph.advanceWidth * scale
              : font.unitsPerEm * scale;
          currentX += advance + letterSpacing;
        });

        return mergedPath;
      }

      function addDecorationRect(svgEl, labelRect, element) {
        const style = window.getComputedStyle(element);
        const background = style.backgroundColor;
        const borderWidth = parseFloat(style.borderTopWidth) || 0;
        const borderStyle = style.borderTopStyle;
        const hasBorder = borderWidth > 0 && borderStyle && borderStyle !== "none";
        const hasFill = background && !isTransparentColor(background);

        if (!hasBorder && !hasFill) return;

        const box = getRelativeRect(element, labelRect);
        const rect = document.createElementNS(SVG_NS, "rect");
        rect.setAttribute("x", box.x);
        rect.setAttribute("y", box.y);
        rect.setAttribute("width", box.width);
        rect.setAttribute("height", box.height);

        const radius = parseFloat(style.borderTopLeftRadius) || 0;
        if (radius > 0) {
          rect.setAttribute("rx", radius);
          rect.setAttribute("ry", radius);
        }

        rect.setAttribute("fill", hasFill ? background : "none");
        if (hasBorder) {
          rect.setAttribute("stroke", style.borderTopColor || "#000000");
          rect.setAttribute("stroke-width", borderWidth);
        } else {
          rect.setAttribute("stroke", "none");
        }

        svgEl.appendChild(rect);
      }

      async function appendTextPathsForElement(svgEl, labelRect, element) {
        const style = window.getComputedStyle(element);
        const font = await loadFontByFamily(style.fontFamily);
        const box = getRelativeRect(element, labelRect);
        const fontSize = parseFloat(style.fontSize) || 16;
        const paddingTop = parseFloat(style.paddingTop) || 0;
        const paddingLeft = parseFloat(style.paddingLeft) || 0;
        const paddingRight = parseFloat(style.paddingRight) || 0;
        const textAlign = style.textAlign || "left";
        const letterSpacing = lengthToPx(style.letterSpacing, fontSize);
        const lineHeight = getLineHeightPx(style.lineHeight, fontSize);
        const color = style.color || "#000000";
        const transform = style.textTransform || "none";

        const lines = (element.innerText || element.textContent || "")
          .replace(/\r\n/g, "\n")
          .split("\n");

        let currentBaseline = box.y + paddingTop + fontSize;
        const effectiveLineHeight = Math.max(lineHeight, fontSize);

        lines.forEach((line) => {
          const content = applyTextTransformValue(line, transform);
          if (!content.trim()) {
            currentBaseline += effectiveLineHeight;
            return;
          }

          const textWidth = getTextWidth(font, content, fontSize, letterSpacing);
          let x = box.x + paddingLeft;
          if (textAlign === "center") {
            x = box.x + box.width / 2 - textWidth / 2;
          } else if (textAlign === "right" || textAlign === "end") {
            x = box.x + box.width - paddingRight - textWidth;
          }

          const path = buildPathForText(font, content, x, currentBaseline, fontSize, letterSpacing);
          let d = "";
          if (typeof path.toPathData === "function") {
            d = path.toPathData(3);
          } else if (typeof path.toSVG === "function") {
            const svgString = path.toSVG();
            const match = svgString.match(/d="([^"]+)"/);
            d = match ? match[1] : "";
          }
          if (d) {
            const pathEl = document.createElementNS(SVG_NS, "path");
            pathEl.setAttribute("d", d);
            pathEl.setAttribute("fill", color);
            svgEl.appendChild(pathEl);
          }

          currentBaseline += effectiveLineHeight;
        });
      }

      async function outlineTextInSvg(svgElement) {
        const textNodes = Array.from(svgElement.querySelectorAll("text"));

        for (const textEl of textNodes) {
          const text = textEl.textContent;
          if (!text || !text.trim()) continue;

          const fontSize = getFontSizeFromText(textEl);
          const fill = getFillFromText(textEl);
          const font = await loadFontByFamily(getFontFamilyFromText(textEl));

          const xAttr = textEl.getAttribute("x");
          const yAttr = textEl.getAttribute("y");
          let x = xAttr ? parseFloat(xAttr) : 0;
          const y = yAttr ? parseFloat(yAttr) : 0;

          // Respect text-anchor so outlined text stays centered/aligned
          const anchor = textEl.getAttribute("text-anchor") || "start";
          if (anchor !== "start") {
            const advanceWidth = font.getAdvanceWidth(text, fontSize);
            if (anchor === "middle") {
              x -= advanceWidth / 2;
            } else if (anchor === "end") {
              x -= advanceWidth;
            }
          }

          // Create a single path for the full string
          const path = font.getPath(text, x, y, fontSize);

          let d;
          if (typeof path.toPathData === "function") {
            d = path.toPathData(2);
          } else if (typeof path.toSVG === "function") {
            const svgString = path.toSVG();
            const m = svgString.match(/d="([^"]+)"/);
            d = m ? m[1] : "";
          } else {
            console.warn(
              "No toPathData/toSVG on opentype path; skipping outlining for this text."
            );
            continue;
          }

          if (!d) continue;

          const pathEl = document.createElementNS("http://www.w3.org/2000/svg", "path");
          pathEl.setAttribute("d", d);
          pathEl.setAttribute("fill", fill);

          const transform = textEl.getAttribute("transform");
          if (transform) {
            pathEl.setAttribute("transform", transform);
          }

          // Replace text with path, keeping everything else intact
          textEl.parentNode.replaceChild(pathEl, textEl);
        }
      }

      // ------------ ORIGINAL LOGIC (only export paths changed) ------------

      const baseBarcodeOptions = {
        format: "ean13",
        lineColor: "#000000",
        background: "#ffffff",
        width: 2,
        height: 20,
        font: DEFAULT_FONT, // only works if font is loaded
        fontSize: 18,
        flat: true,
        textMargin: 0,
      };

      function generateBarcode(code) {
        const errorEl = document.getElementById("error");
        errorEl.textContent = "";

        // Only digits, length 12 or 13
        if (!/^\d{12,13}$/.test(code)) {
          errorEl.textContent = "Code must be 12 or 13 digits (numbers only).";
          return;
        }

        const preview = document.getElementById("barcodePreview");
        if (preview) {
          JsBarcode(preview, code, {
            ...baseBarcodeOptions,
            margin: 10,
          });
        }

        const labelSvg = document.getElementById("labelBarcode");
        if (labelSvg) {
          JsBarcode(labelSvg, code, {
            ...baseBarcodeOptions,
            margin: 0,
          });
        }
      }

      async function downloadSVG() {
        const svg = document.getElementById("barcodePreview");
        const code = document.getElementById("codeInput").value.trim();

        if (!svg || !svg.innerHTML.trim()) {
          alert("Generate a barcode first.");
          return;
        }

        // Work on a clone so on-screen preview stays text-based
        const svgClone = svg.cloneNode(true);
        try {
          await outlineTextInSvg(svgClone);
        } catch (e) {
          console.warn("Could not outline text, exporting as-is:", e);
        }

        const serializer = new XMLSerializer();
        let source = serializer.serializeToString(svgClone);

        if (!source.match(/^<\?xml/)) {
          source = '<?xml version="1.0" encoding="UTF-8"?>\n' + source;
        }

        const blob = new Blob([source], {
          type: "image/svg+xml;charset=utf-8",
        });
        const url = URL.createObjectURL(blob);

        const a = document.createElement("a");
        a.href = url;
        a.download = `ean13-${code || "barcode"}.svg`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }

      async function downloadLabelSvg() {
        const label = document.getElementById("coffeeLabel");
        if (!label) {
          alert("Label not found.");
          return;
        }

        const labelRect = label.getBoundingClientRect();
        const width = Math.round(labelRect.width);
        const height = Math.round(labelRect.height);
        if (!width || !height) {
          alert("Label has no size to export.");
          return;
        }

        const svgEl = document.createElementNS(SVG_NS, "svg");
        svgEl.setAttribute("xmlns", SVG_NS);
        svgEl.setAttribute("width", width);
        svgEl.setAttribute("height", height);
        svgEl.setAttribute("viewBox", `0 0 ${width} ${height}`);

        const labelStyle = window.getComputedStyle(label);
        const backgroundRect = document.createElementNS(SVG_NS, "rect");
        backgroundRect.setAttribute("width", width);
        backgroundRect.setAttribute("height", height);
        backgroundRect.setAttribute(
          "fill",
          isTransparentColor(labelStyle.backgroundColor) ? "#ffffff" : labelStyle.backgroundColor
        );
        svgEl.appendChild(backgroundRect);

        const textElements = LABEL_TEXT_IDS.map((id) => document.getElementById(id)).filter(Boolean);
        textElements.forEach((el) => addDecorationRect(svgEl, labelRect, el));

        for (const element of textElements) {
          try {
            await appendTextPathsForElement(svgEl, labelRect, element);
          } catch (e) {
            console.warn("Could not outline label text element:", element, e);
          }
        }

        const barcode = document.getElementById("labelBarcode");
        if (barcode && barcode.innerHTML.trim()) {
          const barcodeClone = barcode.cloneNode(true);
          barcodeClone.removeAttribute("id");
          const barcodeRect = getRelativeRect(barcode, labelRect);
          barcodeClone.setAttribute("x", barcodeRect.x);
          barcodeClone.setAttribute("y", barcodeRect.y);
          barcodeClone.setAttribute("width", barcodeRect.width);
          barcodeClone.setAttribute("height", barcodeRect.height);
          try {
            await outlineTextInSvg(barcodeClone);
          } catch (e) {
            console.warn("Could not outline text for label barcode:", e);
          }
          svgEl.appendChild(barcodeClone);
        }

        const serializer = new XMLSerializer();
        let source = serializer.serializeToString(svgEl);
        if (!source.match(/^<\?xml/)) {
          source = '<?xml version="1.0" encoding="UTF-8"?>\n' + source;
        }

        const blob = new Blob([svg], {
          type: "image/svg+xml;charset=utf-8",
        });
        const url = URL.createObjectURL(blob);

        const a = document.createElement("a");
        a.href = url;
        a.download = "coffee-label.svg";
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }

      async function bulkDownload() {
        const bulkErrorEl = document.getElementById("bulkError");
        bulkErrorEl.textContent = "";

        const raw = document.getElementById("bulkInput").value;
        const lines = raw
          .split("\n")
          .map((l) => l.trim())
          .filter((l) => l.length > 0);

        if (lines.length === 0) {
          bulkErrorEl.textContent = "Add at least one code (one per line).";
          return;
        }

        const zip = new JSZip();
        const invalid = [];

        for (const line of lines) {
          const code = line;

          if (!/^\d{12,13}$/.test(code)) {
            invalid.push(code);
            continue;
          }

          // Create an in-memory SVG element
          const svg = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "svg"
          );

          JsBarcode(svg, code, {
            ...baseBarcodeOptions,
            margin: 0,
          });

          try {
            await outlineTextInSvg(svg);
          } catch (e) {
            console.warn("Could not outline text for code", code, e);
            // If outlining fails, we still export the text-based SVG
          }

          const serializer = new XMLSerializer();
          let source = serializer.serializeToString(svg);

          if (!source.match(/^<\?xml/)) {
            source = '<?xml version="1.0" encoding="UTF-8"?>\n' + source;
          }

          zip.file(`ean13-${code}.svg`, source);
        }

        if (invalid.length === lines.length) {
          bulkErrorEl.textContent =
            "All lines were invalid. Use 12 or 13 digits per line.";
          return;
        }

        if (invalid.length > 0) {
          bulkErrorEl.textContent =
            "Some codes were skipped (invalid format):\n" + invalid.join("\n");
        }

        const blob = await zip.generateAsync({ type: "blob" });
        const url = URL.createObjectURL(blob);

        const a = document.createElement("a");
        a.href = url;
        a.download = "ean13-barcodes.zip";
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }

      // Wire up UI
      document.getElementById("generateBtn").addEventListener("click", () => {
        const code = document.getElementById("codeInput").value.trim();
        generateBarcode(code);
      });

      document
        .getElementById("downloadBtn")
        .addEventListener("click", downloadSVG);
      document
        .getElementById("bulkDownloadBtn")
        .addEventListener("click", bulkDownload);
      document
        .getElementById("downloadLabelBtn")
        .addEventListener("click", downloadLabelSvg);

      const labelBindings = [
        { inputId: "labelClassInput", targetId: "labelCoffeeClass" },
        { inputId: "labelRegionInput", targetId: "labelCoffeeRegion" },
        {
          inputId: "labelDescriptorsInput",
          targetId: "labelCoffeeDescriptors",
        },
        { inputId: "labelMethodInput", targetId: "labelCoffeeMethod" },
      ];

      labelBindings.forEach(({ inputId, targetId }) => {
        const inputEl = document.getElementById(inputId);
        const targetEl = document.getElementById(targetId);
        if (!inputEl || !targetEl) return;

        const sync = () => {
          targetEl.textContent = inputEl.value;
        };

        inputEl.addEventListener("input", sync);
        sync();
      });

      // Generate once on load with default
      generateBarcode(document.getElementById("codeInput").value.trim());
    </script>
  </body>
</html>
